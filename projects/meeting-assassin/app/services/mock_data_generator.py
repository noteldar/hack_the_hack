"""
Mock data generator for MeetingAssassin demo and testing
"""

import asyncio
import random
from datetime import datetime, timedelta, timezone
from typing import List, Dict, Any, Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.models.user import User
from app.models.meeting import Meeting, MeetingStatus, MeetingPriority, AIDecisionType
from app.models.database import get_async_session
import logging
import json

logger = logging.getLogger(__name__)


class MockDataGenerator:
    """Generate realistic mock data for calendar demonstrations"""

    def __init__(self):
        self.meeting_types = [
            "standup", "review", "planning", "presentation", "interview",
            "training", "client", "one-on-one", "social", "decision"
        ]

        # Realistic meeting titles by type
        self.meeting_templates = {
            "standup": [
                "Daily Standup - {team}",
                "Morning Sync - {team}",
                "Team Standup",
                "Quick Sync - {project}"
            ],
            "review": [
                "Sprint Review - {project}",
                "Code Review Session",
                "Performance Review - {person}",
                "Project Retrospective",
                "Design Review - {feature}"
            ],
            "planning": [
                "Sprint Planning - {project}",
                "Quarterly Planning",
                "Product Roadmap Discussion",
                "Architecture Planning - {system}",
                "Resource Planning Meeting"
            ],
            "presentation": [
                "Demo Day - {project}",
                "Stakeholder Presentation",
                "Product Demo - {feature}",
                "Technical Presentation - {topic}",
                "Progress Update to Leadership"
            ],
            "interview": [
                "Technical Interview - {candidate}",
                "Behavioral Interview - {candidate}",
                "Final Round Interview - {candidate}",
                "Phone Screen - {candidate}",
                "Culture Fit Interview - {candidate}"
            ],
            "client": [
                "Client Check-in - {company}",
                "Requirements Gathering - {project}",
                "Client Demo - {product}",
                "Contract Discussion - {company}",
                "Project Kickoff - {client}"
            ],
            "one-on-one": [
                "1:1 with {person}",
                "Career Development Chat - {person}",
                "Weekly Check-in - {person}",
                "Mentoring Session - {person}",
                "Feedback Session - {person}"
            ],
            "training": [
                "Tech Training - {technology}",
                "Skills Workshop - {skill}",
                "Onboarding Session - {topic}",
                "Security Training",
                "Leadership Development"
            ],
            "social": [
                "Team Lunch",
                "Coffee Chat - {person}",
                "Team Building Activity",
                "Birthday Celebration - {person}",
                "Welcome Lunch - {person}"
            ],
            "decision": [
                "Architecture Decision - {topic}",
                "Go/No-Go Meeting - {project}",
                "Budget Approval - {item}",
                "Strategic Decision - {topic}",
                "Vendor Selection - {category}"
            ]
        }\n\n        self.teams = [\"Engineering\", \"Product\", \"Design\", \"Marketing\", \"Sales\"]\n        self.projects = [\"Phoenix\", \"Apollo\", \"Atlas\", \"Orion\", \"Titan\"]\n        self.people = [\"Sarah\", \"Mike\", \"Alex\", \"Jessica\", \"David\", \"Emma\", \"Ryan\", \"Lisa\"]\n        self.companies = [\"Acme Corp\", \"TechFlow\", \"DataVision\", \"CloudFirst\", \"InnovateLabs\"]\n        self.technologies = [\"React\", \"Python\", \"Kubernetes\", \"GraphQL\", \"TypeScript\"]\n        self.skills = [\"Leadership\", \"Communication\", \"Data Analysis\", \"Project Management\"]\n\n        # Email domains for attendees\n        self.email_domains = [\"company.com\", \"client.co\", \"partner.org\", \"external.net\"]\n\n        # Locations for meetings\n        self.locations = [\n            \"Conference Room A\",\n            \"Conference Room B\",\n            \"Zoom\",\n            \"Google Meet\",\n            \"Microsoft Teams\",\n            \"Huddle Room 1\",\n            \"Main Conference Room\",\n            \"Phone Call\",\n            \"Client Office\",\n            \"Coffee Shop\"\n        ]\n\n    async def generate_demo_user(self, db: AsyncSession) -> User:\n        \"\"\"Generate a demo user with realistic data\"\"\"\n\n        demo_user = User(\n            email=\"demo@meetingassassin.com\",\n            name=\"Demo User\",\n            timezone=\"UTC\",\n            calendar_connected=True,\n            calendar_connected_at=datetime.now(timezone.utc),\n            google_calendar_tokens=json.dumps({\n                \"access_token\": \"mock_access_token\",\n                \"refresh_token\": \"mock_refresh_token\",\n                \"expires_at\": (datetime.now(timezone.utc) + timedelta(hours=1)).isoformat(),\n                \"scope\": \"calendar\",\n                \"token_type\": \"Bearer\"\n            }),\n            preferences={\n                \"autonomous_mode\": True,\n                \"focus_time_blocks\": [(9, 11), (14, 16)],\n                \"max_meetings_per_day\": 6,\n                \"min_buffer_minutes\": 15\n            }\n        )\n\n        db.add(demo_user)\n        await db.commit()\n        await db.refresh(demo_user)\n\n        logger.info(f\"Created demo user: {demo_user.email}\")\n        return demo_user\n\n    async def generate_realistic_meetings(\n        self,\n        user: User,\n        db: AsyncSession,\n        days_back: int = 7,\n        days_forward: int = 30,\n        meetings_per_day: int = 4\n    ) -> List[Meeting]:\n        \"\"\"Generate realistic meeting data\"\"\"\n\n        meetings = []\n        start_date = datetime.now(timezone.utc) - timedelta(days=days_back)\n        end_date = datetime.now(timezone.utc) + timedelta(days=days_forward)\n\n        current_date = start_date.date()\n        meeting_id_counter = 1\n\n        while current_date <= end_date.date():\n            # Skip weekends for most meetings\n            if current_date.weekday() >= 5:\n                current_date += timedelta(days=1)\n                continue\n\n            # Generate meetings for this day\n            daily_meetings = random.randint(2, meetings_per_day + 2)\n\n            # Create meeting time slots for the day\n            available_slots = self._generate_time_slots(current_date)\n            selected_slots = random.sample(available_slots, min(daily_meetings, len(available_slots)))\n\n            for slot_start, slot_end in selected_slots:\n                meeting = await self._create_realistic_meeting(\n                    user, slot_start, slot_end, meeting_id_counter\n                )\n                if meeting:\n                    meetings.append(meeting)\n                    meeting_id_counter += 1\n\n            current_date += timedelta(days=1)\n\n        # Add to database\n        db.add_all(meetings)\n        await db.commit()\n\n        logger.info(f\"Generated {len(meetings)} realistic meetings for user {user.id}\")\n        return meetings\n\n    def _generate_time_slots(self, date) -> List[tuple[datetime, datetime]]:\n        \"\"\"Generate realistic meeting time slots for a day\"\"\"\n\n        slots = []\n        base_datetime = datetime.combine(date, datetime.min.time(), timezone.utc)\n\n        # Common meeting times\n        common_times = [\n            (9, 0, 30),   # 9:00 AM, 30 min\n            (9, 30, 60),  # 9:30 AM, 1 hour\n            (10, 0, 30),  # 10:00 AM, 30 min\n            (10, 30, 60), # 10:30 AM, 1 hour\n            (11, 0, 60),  # 11:00 AM, 1 hour\n            (13, 0, 30),  # 1:00 PM, 30 min\n            (14, 0, 60),  # 2:00 PM, 1 hour\n            (15, 0, 30),  # 3:00 PM, 30 min\n            (15, 30, 60), # 3:30 PM, 1 hour\n            (16, 0, 30),  # 4:00 PM, 30 min\n            (16, 30, 60), # 4:30 PM, 1 hour\n        ]\n\n        for hour, minute, duration in common_times:\n            start_time = base_datetime.replace(hour=hour, minute=minute)\n            end_time = start_time + timedelta(minutes=duration)\n            slots.append((start_time, end_time))\n\n        return slots\n\n    async def _create_realistic_meeting(\n        self,\n        user: User,\n        start_time: datetime,\n        end_time: datetime,\n        meeting_id: int\n    ) -> Optional[Meeting]:\n        \"\"\"Create a single realistic meeting\"\"\"\n\n        # Choose meeting type\n        meeting_type = random.choice(self.meeting_types)\n\n        # Generate title based on type\n        title_template = random.choice(self.meeting_templates[meeting_type])\n        title = self._populate_template(title_template)\n\n        # Generate description\n        description = self._generate_meeting_description(meeting_type, title)\n\n        # Choose location\n        location = random.choice(self.locations)\n        meeting_link = None\n        if location in [\"Zoom\", \"Google Meet\", \"Microsoft Teams\"]:\n            meeting_link = self._generate_meeting_link(location)\n            location = f\"{location} Meeting\"\n\n        # Generate attendees\n        attendees = self._generate_attendees(meeting_type)\n\n        # Calculate duration\n        duration_minutes = int((end_time - start_time).total_seconds() / 60)\n\n        # AI Analysis (simulated)\n        ai_analysis = self._simulate_ai_analysis(meeting_type, title, len(attendees), start_time)\n\n        meeting = Meeting(\n            user_id=user.id,\n            google_event_id=f\"mock_event_{meeting_id}_{random.randint(1000, 9999)}\",\n            calendar_id=\"primary\",\n            title=title,\n            description=description,\n            location=location,\n            meeting_link=meeting_link,\n            start_time=start_time,\n            end_time=end_time,\n            timezone=\"UTC\",\n            duration_minutes=duration_minutes,\n            organizer_email=random.choice(attendees) if attendees else user.email,\n            attendees=attendees,\n            status=MeetingStatus.SCHEDULED,\n            meeting_type=meeting_type,\n            priority=ai_analysis[\"priority\"],\n            ai_importance_score=ai_analysis[\"importance_score\"],\n            ai_conflict_score=ai_analysis[\"conflict_score\"],\n            ai_productivity_impact=ai_analysis[\"productivity_impact\"],\n            ai_decision=ai_analysis[\"decision\"],\n            ai_decision_confidence=ai_analysis[\"confidence\"],\n            ai_decision_reasoning=ai_analysis[\"reasoning\"],\n            last_ai_analysis=datetime.now(timezone.utc)\n        )\n\n        return meeting\n\n    def _populate_template(self, template: str) -> str:\n        \"\"\"Populate template with realistic data\"\"\"\n\n        replacements = {\n            \"{team}\": random.choice(self.teams),\n            \"{project}\": random.choice(self.projects),\n            \"{person}\": random.choice(self.people),\n            \"{company}\": random.choice(self.companies),\n            \"{candidate}\": f\"{random.choice(self.people)} Smith\",\n            \"{client}\": random.choice(self.companies),\n            \"{feature}\": f\"{random.choice(['User Dashboard', 'API Integration', 'Payment System', 'Analytics'])}\",\n            \"{system}\": random.choice([\"Backend\", \"Frontend\", \"Database\", \"Infrastructure\"]),\n            \"{topic}\": random.choice([\"Security\", \"Performance\", \"Scaling\", \"Architecture\"]),\n            \"{technology}\": random.choice(self.technologies),\n            \"{skill}\": random.choice(self.skills),\n            \"{category}\": random.choice([\"CRM\", \"Analytics\", \"Cloud Provider\", \"Security Tools\"]),\n            \"{product}\": random.choice([\"Web App\", \"Mobile App\", \"API\", \"Dashboard\"]),\n            \"{item}\": random.choice([\"Marketing Campaign\", \"New Hire\", \"Software License\", \"Hardware\"])\n        }\n\n        result = template\n        for placeholder, value in replacements.items():\n            result = result.replace(placeholder, value)\n\n        return result\n\n    def _generate_meeting_description(self, meeting_type: str, title: str) -> str:\n        \"\"\"Generate realistic meeting description\"\"\"\n\n        descriptions = {\n            \"standup\": [\n                \"Daily team sync to discuss progress, blockers, and next steps.\",\n                \"Quick team update meeting. Please come prepared with your updates.\",\n                \"Morning standup to align on daily priorities and remove blockers.\"\n            ],\n            \"review\": [\n                \"Comprehensive review session to evaluate progress and outcomes.\",\n                \"Detailed review of deliverables with stakeholder feedback.\",\n                \"Performance evaluation and feedback discussion.\"\n            ],\n            \"planning\": [\n                \"Strategic planning session to define objectives and roadmap.\",\n                \"Detailed planning meeting to scope work and allocate resources.\",\n                \"Forward-looking planning session for next quarter's initiatives.\"\n            ],\n            \"client\": [\n                \"Important client meeting to discuss project requirements and timeline.\",\n                \"Stakeholder alignment session with external partners.\",\n                \"Client check-in to review progress and address concerns.\"\n            ],\n            \"presentation\": [\n                \"Formal presentation to showcase project results and insights.\",\n                \"Demo session highlighting key features and achievements.\",\n                \"Executive presentation on strategic initiatives and outcomes.\"\n            ]\n        }\n\n        base_descriptions = descriptions.get(meeting_type, [\n            \"Team meeting to discuss important topics and make decisions.\",\n            \"Scheduled discussion to align on key priorities.\",\n            \"Regular meeting to maintain team communication and progress.\"\n        ])\n\n        base_description = random.choice(base_descriptions)\n\n        # Add agenda items occasionally\n        if random.random() < 0.3:\n            agenda_items = [\n                \"\\n\\nAgenda:\\n- Review previous action items\",\n                \"- Progress updates from team members\",\n                \"- Discuss upcoming deadlines\",\n                \"- Address blockers and challenges\",\n                \"- Plan next steps and priorities\"\n            ]\n            base_description += \"\\n\".join(agenda_items[:random.randint(2, 4)])\n\n        return base_description\n\n    def _generate_attendees(self, meeting_type: str) -> List[str]:\n        \"\"\"Generate realistic attendee list\"\"\"\n\n        base_attendees = [\"demo@meetingassassin.com\"]  # Always include demo user\n\n        # Different meeting types have different attendee patterns\n        if meeting_type == \"standup\":\n            team_size = random.randint(3, 8)\n        elif meeting_type == \"one-on-one\":\n            team_size = 1  # Just one other person\n        elif meeting_type == \"client\":\n            team_size = random.randint(2, 6)\n        elif meeting_type == \"presentation\":\n            team_size = random.randint(5, 15)\n        else:\n            team_size = random.randint(2, 8)\n\n        # Generate attendee emails\n        for i in range(team_size):\n            person = random.choice(self.people)\n            domain = random.choice(self.email_domains)\n            email = f\"{person.lower()}.{random.choice(['smith', 'jones', 'brown', 'davis'])}@{domain}\"\n            base_attendees.append(email)\n\n        return base_attendees[:team_size + 1]  # Include demo user + others\n\n    def _generate_meeting_link(self, platform: str) -> str:\n        \"\"\"Generate realistic meeting links\"\"\"\n\n        if platform == \"Zoom\":\n            room_id = random.randint(100000000, 999999999)\n            return f\"https://zoom.us/j/{room_id}\"\n        elif platform == \"Google Meet\":\n            code = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=10))\n            return f\"https://meet.google.com/{code[:3]}-{code[3:7]}-{code[7:]}\"\n        elif platform == \"Microsoft Teams\":\n            meeting_id = ''.join(random.choices('0123456789', k=12))\n            return f\"https://teams.microsoft.com/l/meetup-join/{meeting_id}\"\n\n        return None\n\n    def _simulate_ai_analysis(self, meeting_type: str, title: str, attendee_count: int, start_time: datetime) -> Dict[str, Any]:\n        \"\"\"Simulate AI analysis for realistic demo data\"\"\"\n\n        # Base scores by meeting type\n        type_scores = {\n            \"standup\": {\"importance\": 0.3, \"productivity\": 0.2},\n            \"client\": {\"importance\": 0.8, \"productivity\": 0.6},\n            \"presentation\": {\"importance\": 0.9, \"productivity\": 0.7},\n            \"interview\": {\"importance\": 0.7, \"productivity\": 0.5},\n            \"planning\": {\"importance\": 0.8, \"productivity\": 0.8},\n            \"review\": {\"importance\": 0.6, \"productivity\": 0.4},\n            \"one-on-one\": {\"importance\": 0.7, \"productivity\": 0.8},\n            \"training\": {\"importance\": 0.6, \"productivity\": 0.9},\n            \"social\": {\"importance\": 0.2, \"productivity\": -0.1},\n            \"decision\": {\"importance\": 0.9, \"productivity\": 0.8}\n        }\n\n        base_importance = type_scores.get(meeting_type, {\"importance\": 0.5, \"productivity\": 0.3})[\"importance\"]\n        base_productivity = type_scores.get(meeting_type, {\"importance\": 0.5, \"productivity\": 0.3})[\"productivity\"]\n\n        # Add some randomness\n        importance_score = max(0.0, min(1.0, base_importance + random.uniform(-0.2, 0.2)))\n        productivity_impact = max(-1.0, min(1.0, base_productivity + random.uniform(-0.3, 0.3)))\n\n        # Calculate conflict score (simulated)\n        hour = start_time.hour\n        conflict_score = 0.0\n\n        # Focus time conflicts\n        if (9 <= hour <= 11) or (14 <= hour <= 16):\n            conflict_score += 0.3\n\n        # Lunch time conflicts\n        if 12 <= hour <= 13:\n            conflict_score += 0.2\n\n        # Early/late meetings\n        if hour < 9 or hour > 17:\n            conflict_score += 0.4\n\n        # Large meetings have higher conflict potential\n        if attendee_count > 8:\n            conflict_score += 0.2\n\n        conflict_score = min(1.0, conflict_score + random.uniform(-0.1, 0.1))\n\n        # AI Decision logic\n        if importance_score < 0.3 and conflict_score > 0.6:\n            decision = AIDecisionType.AUTO_DECLINE\n            confidence = 0.85\n            reasoning = \"Low importance meeting with high conflict score - auto-declining to protect calendar\"\n        elif importance_score > 0.8:\n            decision = AIDecisionType.AUTO_ACCEPT\n            confidence = 0.9\n            reasoning = \"High importance meeting - auto-accepting\"\n        elif conflict_score > 0.7:\n            decision = AIDecisionType.SUGGEST_RESCHEDULE\n            confidence = 0.7\n            reasoning = \"High conflict detected - suggesting reschedule to optimize calendar\"\n        elif importance_score < 0.4:\n            decision = AIDecisionType.DELEGATE\n            confidence = 0.6\n            reasoning = \"Low importance meeting - consider delegating to team member\"\n        else:\n            decision = AIDecisionType.AUTO_ACCEPT\n            confidence = 0.6\n            reasoning = \"Moderate importance and conflict - accepting with standard monitoring\"\n\n        # Priority based on importance and conflict\n        if importance_score > 0.8:\n            priority = MeetingPriority.HIGH\n        elif importance_score > 0.6 or conflict_score < 0.3:\n            priority = MeetingPriority.MEDIUM\n        else:\n            priority = MeetingPriority.LOW\n\n        return {\n            \"importance_score\": round(importance_score, 2),\n            \"conflict_score\": round(conflict_score, 2),\n            \"productivity_impact\": round(productivity_impact, 2),\n            \"decision\": decision,\n            \"confidence\": round(confidence, 2),\n            \"reasoning\": reasoning,\n            \"priority\": priority\n        }\n\n    async def generate_conflict_scenarios(self, user: User, db: AsyncSession) -> List[Meeting]:\n        \"\"\"Generate specific conflict scenarios for demonstration\"\"\"\n\n        conflict_meetings = []\n        base_date = datetime.now(timezone.utc) + timedelta(days=1)\n        base_date = base_date.replace(hour=9, minute=0, second=0, microsecond=0)\n\n        # Scenario 1: Overlapping meetings\n        meeting1 = Meeting(\n            user_id=user.id,\n            google_event_id=f\"conflict_overlap_1_{random.randint(1000, 9999)}\",\n            title=\"Strategic Planning Session\",\n            description=\"Important planning meeting for Q4 initiatives\",\n            start_time=base_date,\n            end_time=base_date + timedelta(hours=2),\n            meeting_type=\"planning\",\n            ai_importance_score=0.9,\n            ai_conflict_score=0.8,\n            status=MeetingStatus.SCHEDULED\n        )\n\n        meeting2 = Meeting(\n            user_id=user.id,\n            google_event_id=f\"conflict_overlap_2_{random.randint(1000, 9999)}\",\n            title=\"Client Demo - DataVision\",\n            description=\"Product demonstration for key client\",\n            start_time=base_date + timedelta(minutes=30),\n            end_time=base_date + timedelta(hours=1, minutes=30),\n            meeting_type=\"client\",\n            ai_importance_score=0.85,\n            ai_conflict_score=0.9,\n            status=MeetingStatus.SCHEDULED\n        )\n\n        # Scenario 2: Back-to-back meetings without buffer\n        meeting3 = Meeting(\n            user_id=user.id,\n            google_event_id=f\"conflict_buffer_1_{random.randint(1000, 9999)}\",\n            title=\"Technical Review - Authentication System\",\n            description=\"Code review and architecture discussion\",\n            start_time=base_date + timedelta(hours=3),\n            end_time=base_date + timedelta(hours=4),\n            meeting_type=\"review\",\n            ai_importance_score=0.7,\n            ai_conflict_score=0.6\n        )\n\n        meeting4 = Meeting(\n            user_id=user.id,\n            google_event_id=f\"conflict_buffer_2_{random.randint(1000, 9999)}\",\n            title=\"Interview - Senior Developer\",\n            description=\"Technical interview for senior position\",\n            start_time=base_date + timedelta(hours=4),\n            end_time=base_date + timedelta(hours=5),\n            meeting_type=\"interview\",\n            ai_importance_score=0.8,\n            ai_conflict_score=0.7\n        )\n\n        # Scenario 3: Focus time conflict\n        focus_conflict = Meeting(\n            user_id=user.id,\n            google_event_id=f\"conflict_focus_{random.randint(1000, 9999)}\",\n            title=\"Social Coffee Chat\",\n            description=\"Casual team building coffee\",\n            start_time=base_date.replace(hour=10),  # During focus time\n            end_time=base_date.replace(hour=10) + timedelta(minutes=30),\n            meeting_type=\"social\",\n            ai_importance_score=0.2,\n            ai_conflict_score=0.8,\n            ai_decision=AIDecisionType.AUTO_DECLINE,\n            ai_decision_reasoning=\"Low priority meeting during focus time\"\n        )\n\n        conflict_meetings.extend([meeting1, meeting2, meeting3, meeting4, focus_conflict])\n\n        db.add_all(conflict_meetings)\n        await db.commit()\n\n        logger.info(f\"Generated {len(conflict_meetings)} conflict scenario meetings\")\n        return conflict_meetings\n\n    async def generate_full_demo_dataset(\n        self,\n        db: AsyncSession,\n        user_email: str = \"demo@meetingassassin.com\"\n    ) -> Dict[str, Any]:\n        \"\"\"Generate complete demo dataset\"\"\"\n\n        # Check if demo user already exists\n        result = await db.execute(select(User).where(User.email == user_email))\n        demo_user = result.scalar_one_or_none()\n\n        if not demo_user:\n            demo_user = await self.generate_demo_user(db)\n        else:\n            logger.info(f\"Using existing demo user: {demo_user.email}\")\n\n        # Generate realistic meetings\n        meetings = await self.generate_realistic_meetings(\n            demo_user, db, days_back=14, days_forward=30, meetings_per_day=5\n        )\n\n        # Generate conflict scenarios\n        conflict_meetings = await self.generate_conflict_scenarios(demo_user, db)\n\n        return {\n            \"user\": {\n                \"id\": demo_user.id,\n                \"email\": demo_user.email,\n                \"name\": demo_user.name,\n                \"calendar_connected\": demo_user.calendar_connected\n            },\n            \"meetings_generated\": len(meetings),\n            \"conflict_scenarios\": len(conflict_meetings),\n            \"total_meetings\": len(meetings) + len(conflict_meetings),\n            \"date_range\": {\n                \"start\": (datetime.now(timezone.utc) - timedelta(days=14)).isoformat(),\n                \"end\": (datetime.now(timezone.utc) + timedelta(days=30)).isoformat()\n            }\n        }\n\n\n# Global instance\nmock_data_generator = MockDataGenerator()\n\n\n# CLI function for generating demo data\nasync def generate_demo_data():\n    \"\"\"CLI function to generate demo data\"\"\"\n    async with get_async_session() as db:\n        result = await mock_data_generator.generate_full_demo_dataset(db)\n        print(json.dumps(result, indent=2))\n        print(f\"\\nDemo data generated successfully!\")\n        print(f\"Demo user: {result['user']['email']}\")\n        print(f\"Total meetings: {result['total_meetings']}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(generate_demo_data())"